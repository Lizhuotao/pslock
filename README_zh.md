# pslock: 基于 Redis 的高效分布式锁

`pslock` 是一个 Go 语言库，它使用 Redis 实现了一个强大且高效的分布式锁机制。它利用 `SETNX` 进行原子锁获取，并通过 Redis PubSub 实现低延迟通知，同时使用轮询机制作为最终保障。

这种混合方法通过以下方式确保安全的并发操作：

1. **快速路径获取**：通过原子 `SETNX` 命令尝试获取锁。
2. **高效等待**：如果锁被占用，`pslock` 会订阅 Redis PubSub 通道，在锁释放时立即获得通知。
3. **弹性回退**：同时，它使用轮询机制重新尝试获取锁，防止因网络问题或 Redis 故障转移导致的 PubSub 消息丢失。
4. **优雅释放**：锁会被干净地释放，通过 PubSub 通知所有等待的实例，并终止内部等待机制（PubSub 订阅、轮询器）。

**主要优势**：与纯轮询锁相比，`pslock` 通过 PubSub 即时检测锁释放，显著降低了延迟和 CPU 开销。它通过使用轮询作为后备方案来保持可靠性，有效解决了 Redis PubSub 的"最多一次"投递保证问题。

## 安装

```bash
go get github.com/Lizhuotao/pslock
```

## 使用示例（概念性示例）
```go
// 创建 Redis 客户端
client := redis.NewClient(&redis.Options{
  Addr: "localhost:6379",
})
defer client.Close()

r := pslock.New(client)

name := "test-lock"
// 创建分布式锁实例
lock := r.NewMutex(name)

// 创建上下文
ctx := context.Background()

// 尝试获取锁
err := lock.Lock(ctx)
if err != nil {
  log.Fatalf("获取锁失败: %v", err)
}

// 持有锁时执行一些工作
fmt.Println("已获取锁，正在执行工作...")
time.Sleep(2 * time.Second)

// 释放锁
err = lock.Unlock(ctx)
if err != nil {
  log.Fatalf("释放锁失败: %v", err)
}

fmt.Println("锁释放成功")
```

## 特性

- **低延迟**：通过 PubSub 实现近实时的锁获取通知。
- **高弹性**：轮询后备机制防止因丢失 PubSub 消息导致的死锁。
- **降低 CPU 开销**：最小化纯轮询解决方案中常见的忙等待。
- **原子操作**：使用 Redis `SETNX` 实现安全的锁获取。
- **死锁预防**：设计上能够抵御常见的分布式系统故障。
- **可配置超时**：支持锁过期和获取超时设置。

## 工作原理

锁机制遵循以下步骤：

1. **初始获取尝试**：
   - 客户端执行 `SET key value NX PX milliseconds`（如果不存在则设置，并设置过期时间）。
   - 如果成功，锁被获取，客户端可以继续执行其临界区。`value` 通常是锁持有者的唯一标识符。

2. **阻塞流程（如果锁已被持有）**：
   - 如果 `SETNX` 命令失败（意味着锁已被其他进程持有），客户端进入等待状态：
     - **订阅 PubSub**：客户端订阅特定的 Redis PubSub 通道（例如 `pslock_channel:<lock_key>`）。此通道用于广播锁释放通知。
     - **启动轮询协程**：启动单独的协程定期重新尝试通过 `SETNX` 获取锁。这作为安全网。
     - **等待通知或轮询成功**：客户端等待以下情况之一：
       - PubSub 通道上的消息表明锁可能已被释放。收到消息后，立即再次尝试 `SETNX`。
       - 轮询协程通过 `SETNX` 成功获取锁。
       - 达到可配置的获取超时，或提供的上下文被取消。
   - 如果锁成功获取（通过 PubSub 触发或轮询），取消 PubSub 订阅并终止轮询协程。客户端可以继续执行。

3. **解锁过程**：
   - 持有锁的客户端释放锁时：
     - 在 Redis 上执行 `DEL key` 命令删除锁键。
     - 向相应的 PubSub 通道发布消息，通知等待的客户端锁已被释放。
   - 客户端端（对于正在等待并现在获取锁的实例）：
     - 一旦锁被获取（或尝试被中止），取消订阅 PubSub 通道。
     - 终止其内部轮询协程。

## 为什么采用这种混合方法？

1. **为什么使用 `SETNX PX`？**
   - **原子性**：`SETNX` 是原子操作，确保在任何给定时间只有一个客户端可以获取锁。
   - **锁过期（`PX` 选项）**：设置锁的过期时间至关重要。它防止锁持有客户端在释放锁之前崩溃导致的无限死锁。

2. **为什么使用 PubSub？**
   - **效率和低延迟**：PubSub 允许客户端在锁释放时几乎立即得到通知，而不是重复轮询 Redis。这显著减少了获取已释放锁的延迟，并最小化了客户端和 Redis 服务器上不必要的网络流量和 CPU 负载。

3. **为什么同时使用轮询？**
   - **防止消息丢失**：Redis PubSub 提供"最多一次"的投递保证。没有确认机制，消息也不会持久化。如果发生网络波动，或 Redis 在消息传输过程中发生主从故障转移，这些通知可能会丢失。
   - **死锁预防**：如果没有后备机制，丢失的 PubSub 消息可能导致客户端无限期等待永远不会到达的通知，从而导致死锁。轮询确保即使 PubSub 消息丢失，客户端最终也会重新尝试并获取锁。

## 配置选项（示例）

`pslock` 可以配置以下选项：

- **锁过期时间**：锁在自动过期前持有的默认持续时间（与 `SETNX PX` 一起使用）。
- **轮询间隔**：轮询机制尝试获取锁的频率。
- **获取超时**：客户端等待获取锁的最大时间。
- **重试次数**：（可选）某些 Redis 操作的重试次数。

## 限制和注意事项

- **Redis 作为单点故障**：此实现依赖于单个 Redis 实例（或集群/哨兵设置中的主节点）。如果 Redis 宕机，锁机制将失败。对于高可用性，考虑使用 Redis Sentinel 或 Redis Cluster，尽管这会增加客户端的 Redis 连接管理复杂性。
- **公平性**：此锁不是严格公平的（FIFO）。当锁被释放时，任何等待的客户端（无论是通过 PubSub 通知还是轮询成功）都可能获取它。真正的公平性通常需要更复杂的服务器端脚本（例如，使用 Lua 和 Redis 列表）。
- **Redlock 算法**：对于需要更高保证以防止多个独立 Redis 主节点（不是标准的主从复制）数据不一致的场景，考虑 Redlock 算法及其影响。本文描述的 `pslock` 适用于单个 Redis 主节点或正确管理的主从设置。

## 贡献

欢迎贡献！请随时提交问题或拉取请求。

## 许可证

MIT 许可证。详见 `LICENSE` 文件。 